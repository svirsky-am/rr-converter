# RN 30.12.25
```
make all
```
# RN 29.12.25

## Правка чтения из буфера
По поводу трейта Write:
Если я правильно понял, то во write луче просто накапливать сырые байты , в обработку уже делать во  flush . Перенес detect_and_decode во flush.

^^^
Да, в твоём случае можно и так. Но учти, что это не 100% решение - ты ведь экспортируешь свой `FinConverter` из lib-крейта наружу. Если кто-то будет в него писать (как во `Write`) и звать `flush` в тот момент, когда ты к этому не готов, будет плохо :)

Я бы, если честно, посоветовал бы тебе поступить немного по другому. У тебя сейчас есть структура `Wallet` и все форматы по сути - это `Vec<Wallet>`. В идеале твоя функция `parse_input_and_serialize_via_trait` должна принимать не `Read` и `Write`, а input и output. Их можно реализовать множеством способов. Например, как `trait WalletSource { fn read() -> Vec<Wallet>; }` + `trait WalletTarget { fn write(self, wallets: &[Wallet]); }` + 3 реализации этих трейтов (csv, camt053 и mt940). Вся функция - это грубо `target.write(source.read());`. А c Read/Write уже надо работать внутри этих реализаций.

Но твоя концепция имеет право на жизнь, хотя эту фишку с `parse-on-flush` лучше не экспортировать из крейта.

## Детали реализации парсера
Имели место большие трубности при сопоставлении проверочных файлов между собой. Сущности описания выписок, кошельков и транзакций слишком сильно отличаются в каждом из форматов. 
Пример `MT940_github_1.mt940` содержит в себе много фанансовых выписок, что не ложится на camt053 или в выписку от сбербанка.
Возможно сущности должны были выглядеть так:
> Выписка -> перечень аккаунтнов -> перечень кошельков/счетов -> транзакции /балансы   

Сейчас реализовано как-то так:
> Выписка -> перечень кошельков/счетов -> транзакции /балансы   

Выписка из Сбербанка - это не "чистый" csv , а csv-фрагмент с дополнительными полями и метаинформацией. Перед парсингом csv его потребовалось еще "фиксить" - править заголовки и убирать мешающиеся переносы в ячейках. Далее формат выписки от сбербанка назывался как `extra_fin_csv` . При парсинге выписки `extra_fin_csv` в camt или mt940 вставляется кириллица, что не позволяет сделать тест на циркулярный парсинг .

По результатам первого ревью было предложено пользоваться крейтом для парсинга `swift_mt_message`. Ни предложенный крейт, ни другие, которые я нашел в инетрнете не смогли распарсить данные примеры без ошибок. Разобрать ошибки от этих крейтов самостоятельно у меня не получилось, поэтому пришлось писать парсер самостоятельно. К сожелению были выявлены очень досадные искажения в тестовых наборах:
- `0940` в MT940_github_1.mt940 и `O940` в MT_940_oracle.mt94;
- В этом же примере были любопытные float значения из букв `50,OO` и были лишние теги `:86`. 

Пример `MT_940_oracle.mt940` был немного подкорректирован чтобы его можно было использовать для тестов. Был подставлен числовой reference для транзакций :61 вместо `NONREF`. Вставлен `{5:}`, чтобы унифицировать regexp с другим примером. Также были убраны лишние пробелы.т.к они принуждали усложнять regexp для парсинга. В транзакции `:61` вставлены времена перевода 00:00 для унификации с `MT940_github_1.mt940`. Файл `MT_940_aiophotoz.mt940` сильно отличается от других примеров и кажется сильно отличается от спецификации `mt940`, поэтому он не поддерживается.

^^^
Вообще, с этими форматами и примерами файлов действительно множество проблем. Если ты в курсе, сейчас есть вторая опция для этого проекта - там другие форматы файлов, с чётко описанной структурой (именно потому что для CAMT053/MT940 сложно написать реально работающий парсер). Если хочешь, можно переключиться на эту вторую опцию :) Но если решишь остаться здесь - я точно не буду придираться к тонкостям реализации конкретных форматов. Главное - сделай такие примеры, которые работают с твоими парсерами и положи их в репозиторий. Потом пройдёмся по чек-листу, убедимся что всё необходимое есть (корректное использование Read/Write, отсутствуие unwrap, документация для публичных элементов, корректная обработка ошибок)

Мелкие проблемы:
  - время транзакций для camt053 и mt940 указывается с часами и секундами, а в выписке сбербанка только дата. При конвертации из extrafin csv приходится вставлять 00:00. В camt053 также есть метка , которая подтверждает транзакцию;
  - у транзаций camt053 зафиксировано время бронирования и время подтверждения транзакции, но подтвержения нет у других форматов;
  - сложновато было понять как сериализовать данные из xml c помощью quick_xml+serde, поэтому была применена чуть более простая библиотека `roxml`. Но у `quick_xml` был применен при рендере; 
  - идендитификаторы выписок то int, то str (как в случае со сбербанком);
  - два примера camt053 и все три примера mt940 не похожи по структуре между собой;
  - Не получлиось восопльзоваться предложенным парвером mt940 т.к. он не смог без ошибок спарсить ни один из примеров

# Сбока и тесты. 
Сборка библиотеки:
```sh
cargo build -p rr-parser-lib --verbose
```
Сборка cli-утилиты :
```sh
cargo build -p rr-file-processor --verbose
```
Запуск тестов для библиоетеки
```sh
cargo test -p rr-parser-lib --verbose
```
Запуск тестов для cli-утилиты
```sh
cargo test -p rr-file-processor --verbose
```
# Запуск утилиты (пока поломан) 
```sh
target/debug/rr-file-processor \
                --in-format csv --out-format xml \
                --input  - \
                --output output/formatted/stdin_csv_to_xml
```
# refs
https://github.com/r3bb1t/coverage_formats/blob/main/Readme.md

cargo run -p sandbox_env